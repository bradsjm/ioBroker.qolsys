{
  "version": 3,
  "sources": ["../../src/lib/qolsys-event-parser.ts"],
  "sourcesContent": ["import { EventEmitter } from \"events\";\nimport { EventType, InfoType, ZoneEventType } from \"../enums\";\nimport { AlarmJson, ArmingJson, ErrorJson, PartitionJson, PayloadJson, ZoneJson } from \"../interfaces\";\nimport { CountdownTimer } from \"./countdown-timer\";\n\n/**\n * Qolsys Panel Event Parser.\n */\nexport class QolsysEventParser extends EventEmitter {\n    countdown = new CountdownTimer<ArmingJson>();\n    private log: ioBroker.Logger;\n\n    /**\n     * Event parser constructor.\n     *\n     * @param {ioBroker.Logger} logger - Adapter logger.\n     *\n     * @emits alarm - Emits an event with an alarm type {AlarmType} payload.\n     * @emits arming - Emits an event with an arming type {ArmingType} payload.\n     * @emits error - Emits an event with a string describing the error.\n     * @emits partition - Emits an event with a partition {PartitionJson} payload.\n     * @emits secureArm - Emits an event with a secure arming payload.\n     * @emits zone - Emits an event with a zone {ZoneJson} payload.\n     */\n    constructor(logger: ioBroker.Logger) {\n        super({ captureRejections: true });\n        this.log = logger;\n        this.countdown.on(\"countdown\", this.onCountdown.bind(this));\n        this.countdown.on(\"stopped\", this.onCountdownStopped.bind(this));\n    }\n\n    // List of partitions\n    private _partitions: PartitionJson[] = [];\n\n    /**\n     * Get the list of partitions\n     *\n     * @return {PartitionJson[]}\n     */\n    public get partitions(): readonly PartitionJson[] {\n        return this._partitions;\n    }\n\n    /**\n     * Check if a partition is faulted by checking any zones report \"Open\"\n     * @param partitionId The ID of the partition (zero based)\n     * @return {boolean} True if the partition is secure, undefined if partition does not exist\n     */\n    public isFaulted(partitionId: number): boolean | undefined {\n        const partition = this.partitions.find(partition => partition.partition_id === partitionId);\n        return partition?.zone_list.some((zone) => zone.status === \"Open\");\n    }\n\n    /**\n     * Parses an event payload and emits events based on the event type and associated information.\n     * Currently handles event types: INFO, ZONE, ARMING, ALARM, ERROR. Any unrecognized event type is logged as a warning.\n     *\n     * @param {PayloadJson} payload - The event payload to parse.\n     */\n    public parseEventPayload(payload: PayloadJson): void {\n        switch (payload.event) {\n            case EventType.INFO:\n                this.handleInfoEvent(payload);\n                break;\n\n            case EventType.ZONE:\n                this.handleZone(payload);\n                break;\n\n            case EventType.ARMING:\n                this.handleArmingEvent(payload);\n                break;\n\n            case EventType.ALARM:\n                this.handleAlarmEvent(payload);\n                break;\n\n            case EventType.ERROR:\n                this.handleErrorEvent(payload);\n                break;\n\n            default:\n                this.log.warn(\"unknown event type: \" + JSON.stringify(payload));\n                break;\n        }\n    }\n\n    private handleAlarmEvent(payload: PayloadJson): void {\n        if (payload.alarm_type != null && payload.partition_id != null) {\n            const event: AlarmJson = {\n                alarm_type: payload.alarm_type,\n                partition_id: payload.partition_id\n            };\n            this.emit(\"alarm\", event);\n        }\n    }\n\n    private handleArmingEvent(payload: PayloadJson): void {\n        if (payload.arming_type != null && payload.partition_id != null) {\n            const event: ArmingJson = {\n                arming_type: payload.arming_type,\n                partition_id: payload.partition_id,\n                delay: payload.delay\n            };\n            if (event.delay != null) {\n                this.countdown.start(event.delay, event);\n                return;\n            } else if (this.countdown.isRunning) {\n                this.countdown.stop();\n            }\n            this.emit(\"arming\", event);\n        } else {\n            this.log.warn(\"unknown ARMING event: \" + JSON.stringify(payload));\n        }\n    }\n\n    private handleErrorEvent(payload: PayloadJson): void {\n        if (payload.error_type != null && payload.description != null && payload.partition_id != null) {\n            const event: ErrorJson = {\n                description: payload.description,\n                error_type: payload.error_type,\n                partition_id: payload.partition_id\n            }\n            this.emit(\"error\", event);\n        } else {\n            this.log.warn(\"unknown ERROR event: \" + JSON.stringify(payload));\n        }\n    }\n\n    private handleInfoEvent(payload: PayloadJson): void {\n        switch (payload.info_type) {\n            case InfoType.SUMMARY:\n                this.handleSummaryInfo(payload);\n                break;\n\n            case InfoType.SECURE_ARM:\n                this.handleSecureArmInfo(payload);\n                break;\n\n            default:\n                this.log.warn(\"unknown INFO type: \" + payload.info_type);\n                break;\n        }\n    }\n\n    /**\n     * Parse an array of PartitionJson objects, emitting 'partition' and 'zone' events.\n     * Only zones with a zone_alarm_type greater than 0 are considered valid and emitted.\n     *\n     * @param {PartitionJson[]} partitions - An array of PartitionJson objects to parse.\n     *\n     * @emits partition - Emits an event with a {PartitionJson} object.\n     * @emits zone - Emits an event with a {ZoneJson} object.\n     */\n    private handlePartitionInfo(partitions: PartitionJson[]): void {\n        // emit all partition events\n        partitions.forEach((partition) => {\n            this.emit(\"partition\", partition);\n        });\n\n        // emit all zone events\n        partitions.forEach((partition) => {\n            partition.zone_list.forEach((zone) => {\n                this.emit(\"zone\", zone, \"info\");\n            })\n        });\n    }\n\n    private handleSecureArmInfo(payload: PayloadJson): void {\n        if (typeof payload.value === \"boolean\" && payload.partition_id) {\n            this.emit(\"secureArm\", {\n                partition_id: payload.partition_id,\n                secureArm: payload.value\n            });\n        } else {\n            this.log.warn(\"unknown secureArm event: \" + JSON.stringify(payload));\n        }\n    }\n\n    private handleSummaryInfo(payload: PayloadJson): void {\n        this.log.debug(\"summary: \" + JSON.stringify(payload));\n        if (payload.partition_list) {\n            this._partitions = payload.partition_list;\n            this.handlePartitionInfo(payload.partition_list);\n        } else {\n            this.log.warn(\"unknown partition event: \" + JSON.stringify(payload));\n        }\n    }\n\n    /**\n     * Handle a zone event.\n     *\n     * @param payload The zone event payload\n     */\n    private handleZone(payload: PayloadJson): void {\n        if (payload.zone) {\n            switch (payload.zone_event_type) {\n                case ZoneEventType.ZONE_ACTIVE:\n                    this.handleZoneActive(payload.zone);\n                    break;\n\n                case ZoneEventType.ZONE_ADD:\n                case ZoneEventType.ZONE_UPDATE:\n                    this.handleZoneUpdate(payload.zone);\n                    break;\n\n                case ZoneEventType.ZONE_DELETE:\n                    this.handleZoneDelete(payload.zone);\n                    break;\n\n                default:\n                    this.log.warn(\"unknown zone event type: \" + JSON.stringify(payload));\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Invoked when a zone is active.\n     * Locates and updates the matching partition zone detail and emits a complete 'zone' event.\n     *\n     * @param zone The zone object\n     *\n     * @emits zone - Emits an event with a {ZoneJson} object\n     */\n    private handleZoneActive(zone: ZoneJson): void {\n        this.log.debug(\"zone active: \" + JSON.stringify(zone));\n        if (!this._partitions.some((partition) => {\n            return partition.zone_list.some((z) => {\n                if (z.zone_id === zone.zone_id) {\n                    this.emit(\"zone\", Object.assign(z, zone), \"active\");\n                    return true;\n                }\n                return false;\n            })\n        })) {\n            this.log.warn(\"zone not found: \" + JSON.stringify(zone));\n        }\n    }\n\n    /**\n     * Invoked when a zone is deleted to remove the matching partition zone detail.\n     *\n     * @param zone The zone object\n     *\n     * @emits zone - If the zone was found, emits a delete event with a {ZoneJson} object\n     */\n    private handleZoneDelete(zone: ZoneJson): void {\n        this.log.debug(\"zone delete: \" + JSON.stringify(zone));\n        this._partitions = this._partitions.map((partition) => {\n            const updatedPartition = { ...partition }; // Copy the partition object to avoid mutation\n            updatedPartition.zone_list = updatedPartition.zone_list.filter((z) => z.zone_id !== zone.zone_id);\n\n            // If zone was removed, emit 'delete' event\n            if (updatedPartition.zone_list.length < partition.zone_list.length) {\n                this.emit(\"zone\", zone, \"delete\");\n            } else {\n                this.log.debug(\"unable to delete zone: \" + JSON.stringify(zone));\n            }\n\n            return updatedPartition;\n        });\n    }\n\n    /**\n     * Invoked when a zone is updated or added.\n     * Locates and updates any matching partition zone detail or adds a new one\n     * and emits a complete 'zone' event.\n     *\n     * @param zone The zone object\n     *\n     * @emits zone - Emits an event with a {ZoneJson} object\n     */\n    private handleZoneUpdate(zone: ZoneJson): void {\n        this.log.debug(\"zone update: \" + JSON.stringify(zone));\n        const partition = this._partitions.find(p => p.partition_id === zone.partition_id);\n        if (partition !== undefined) {\n            const idx = partition.zone_list.findIndex((z) => z.zone_id === zone.zone_id);\n            if (idx === -1) {\n                partition.zone_list.push(zone);\n            } else {\n                partition.zone_list[idx] = zone;\n            }\n        }\n        this.emit(\"zone\", zone, \"update\");\n    }\n\n    private onCountdown(seconds: number, payload: ArmingJson): void {\n        this.emit(\"arming\", {\n            arming_type: payload.arming_type,\n            partition_id: payload.partition_id,\n            delay: seconds || payload.delay\n        });\n    }\n\n    private onCountdownStopped(payload: ArmingJson): void {\n        this.emit(\"arming\", payload);\n    }\n}\n"],
  "mappings": "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",
  "names": ["partition"]
}
