{
  "version": 3,
  "sources": ["../../src/lib/qolsys-event-parser.ts"],
  "sourcesContent": ["import { EventEmitter } from \"events\";\nimport { EventType, InfoType, ZoneEventType } from \"../enums\";\nimport { AlarmJson, ArmingJson, ErrorJson, PartitionJson, PayloadJson, ZoneJson } from \"../interfaces\";\nimport { CountdownTimer } from \"./countdown-timer\";\n\n/**\n * Qolsys Panel Event Parser.\n */\nexport class QolsysEventParser extends EventEmitter {\n    countdown = new CountdownTimer<ArmingJson>();\n    private log: ioBroker.Logger;\n\n    /**\n     * Event parser constructor.\n     *\n     * @param {ioBroker.Logger} logger: Adapter logger.\n     *\n     * @emits alarm: Emits an event with an alarm type {AlarmType} payload.\n     * @emits arming: Emits an event with an arming type {ArmingType} payload.\n     * @emits error: Emits an event with a string describing the error.\n     * @emits partition: Emits an event with a partition {PartitionJson} payload.\n     * @emits secureArm: Emits an event with a secure arming payload.\n     * @emits zone: Emits an event with a zone {ZoneJson} payload.\n     */\n    constructor(logger: ioBroker.Logger) {\n        super();\n        this.log = logger;\n        this.countdown.on(\"countdown\", this.onCountdown.bind(this));\n        this.countdown.on(\"stopped\", this.onCountdownStopped.bind(this));\n    }\n\n    // List of partitions\n    private _partitions: PartitionJson[] = [];\n\n    /**\n     * Returns the list of partitions\n     *\n     * @return {PartitionJson[]} List of partitions\n     */\n    public get partitions(): readonly PartitionJson[] {\n        return this._partitions;\n    }\n\n    /**\n     * Check if a partition is faulted by checking any zones report \"Open\"\n     *\n     * @param {number} partitionId: The ID of the partition (zero based)\n     * @return {boolean|undefined} True if the partition is secure, undefined if partition does not exist\n     */\n    public isFaulted(partitionId: number): boolean | undefined {\n        const partition = this.partitions.find(partition => partition.partition_id === partitionId);\n        return partition?.zone_list.some((zone) => zone.status === \"Open\");\n    }\n\n    /**\n     * Parses an event payload and emits events based on the event type and associated information.\n     * Currently handles event types: INFO, ZONE, ARMING, ALARM, ERROR.\n     * Any unrecognized event type is logged as a warning.\n     *\n     * @param {PayloadJson} payload: The event payload to parse.\n     */\n    public parseEventPayload(payload: PayloadJson): void {\n        switch (payload.event) {\n            case EventType.INFO:\n                this.handleInfoEvent(payload);\n                break;\n\n            case EventType.ZONE:\n                this.handleZone(payload);\n                break;\n\n            case EventType.ARMING:\n                this.handleArmingEvent(payload);\n                break;\n\n            case EventType.ALARM:\n                this.handleAlarmEvent(payload);\n                break;\n\n            case EventType.ERROR:\n                this.handleErrorEvent(payload);\n                break;\n\n            default:\n                this.log.warn(\"unknown event type: \" + JSON.stringify(payload));\n                break;\n        }\n    }\n\n    /**\n     * The handleAlarmEvent function is called when the alarm event is received from the system.\n     * It emits an &quot;alarm&quot; event with a payload of type AlarmJson.\n     *\n     * @param payload: PayloadJson Pass the payload from the event to this function\n     *\n     * @emits alarm: Emits an event with an alarm type {AlarmJson} payload.\n     */\n    private handleAlarmEvent(payload: PayloadJson): void {\n        if (payload.alarm_type != null && payload.partition_id != null) {\n            const event: AlarmJson = {\n                alarm_type: payload.alarm_type,\n                partition_id: payload.partition_id\n            };\n            this.emit(\"alarm\", event);\n        }\n    }\n\n    /**\n     * The handleArmingEvent function is called when the payload.event_type is &quot;ARMING&quot;.\n     * It checks if the arming_type and partition_id are not null, then it creates an ArmingJson object with those values.\n     * If there's a delay value in the payload, it starts a countdown using that value and passes in the event object as well.\n     * If there's no delay or if there was already a countdown running (which would be stopped), then this function emits an &quot;arming&quot; event with that event object as its argument.\n     *\n     * @param payload: PayloadJson Pass the payload from the event to this function\n     *\n     * @emits arming: Emits an event with an arming type {ArmingType} payload.\n     */\n    private handleArmingEvent(payload: PayloadJson): void {\n        if (payload.arming_type != null && payload.partition_id != null) {\n            const event: ArmingJson = {\n                arming_type: payload.arming_type,\n                partition_id: payload.partition_id,\n                delay: payload.delay\n            };\n            if (event.delay != null) {\n                this.countdown.start(event.delay, event);\n                return;\n            } else if (this.countdown.isRunning) {\n                this.countdown.stop();\n            }\n            this.emit(\"arming\", event);\n        } else {\n            this.log.warn(\"unknown ARMING event: \" + JSON.stringify(payload));\n        }\n    }\n\n    /**\n     * The handleErrorEvent function is called when the client receives an ERROR event from the system.\n     * The function emits a &quot;error&quot; event with an ErrorJson object as its payload.\n     *\n     * @param {PayloadJson} payload: The payload of the event\n     *\n     * @emits error: Emits an event with an error type {ErrorJson} payload.\n     */\n    private handleErrorEvent(payload: PayloadJson): void {\n        if (payload.error_type != null && payload.description != null && payload.partition_id != null) {\n            const event: ErrorJson = {\n                description: payload.description,\n                error_type: payload.error_type,\n                partition_id: payload.partition_id\n            }\n            this.emit(\"error\", event);\n        } else {\n            this.log.warn(\"unknown ERROR event: \" + JSON.stringify(payload));\n        }\n    }\n\n    /**\n     * The handleInfoEvent function handles the INFO event.\n     *\n     * @param {PayloadJson} payload: The payload of the message\n     */\n    private handleInfoEvent(payload: PayloadJson): void {\n        switch (payload.info_type) {\n            case InfoType.SUMMARY:\n                this.handleSummaryInfo(payload);\n                break;\n\n            case InfoType.SECURE_ARM:\n                this.handleSecureArmInfo(payload);\n                break;\n\n            default:\n                this.log.warn(\"unknown INFO type: \" + payload.info_type);\n                break;\n        }\n    }\n\n    /**\n     * The handlePartitionInfo function is called when the system sends a partition event.\n     * It parses an array of PartitionJson objects, emitting 'partition' and 'zone' events.\n     *\n     * @param {PartitionJson[]} partitions: An array of PartitionJson objects to parse.\n     *\n     * @emits partition: Emits an event with a {PartitionJson} object.\n     * @emits zone: Emits an event with a {ZoneJson} object.\n     */\n    private handlePartitionInfo(partitions: PartitionJson[]): void {\n        // emit all partition events\n        partitions.forEach((partition) => {\n            this.emit(\"partition\", partition);\n        });\n\n        // emit all zone events\n        partitions.forEach((partition) => {\n            partition.zone_list.forEach((zone) => {\n                this.emit(\"zone\", zone, \"info\");\n            })\n        });\n    }\n\n    /**\n     * The handleSecureArmInfo function is called when the system sends a secureArm event.\n     * The function emits an event with the partition_id and secureArm value from the payload.\n     *\n     * @param {PayloadJson} payload: The payload of the event\n     */\n    private handleSecureArmInfo(payload: PayloadJson): void {\n        if (typeof payload.value === \"boolean\" && payload.partition_id) {\n            this.emit(\"secureArm\", {\n                partition_id: payload.partition_id,\n                secureArm: payload.value\n            });\n        } else {\n            this.log.warn(\"unknown secureArm event: \" + JSON.stringify(payload));\n        }\n    }\n\n    /**\n     * The handleSummaryInfo function is called when the client receives a summary event.\n     * The function parses the payload and updates the partitions array with new partition information.\n     *\n     * @param {PayloadJson} payload: The payload of the event\n     */\n    private handleSummaryInfo(payload: PayloadJson): void {\n        this.log.debug(\"summary: \" + JSON.stringify(payload));\n        if (payload.partition_list) {\n            this._partitions = payload.partition_list;\n            this.handlePartitionInfo(payload.partition_list);\n        } else {\n            this.log.warn(\"unknown partition event: \" + JSON.stringify(payload));\n        }\n    }\n\n    /**\n     * The handleZone function is called when a zone event occurs.\n     *\n     * @param {PayloadJson} payload: The payload of the event\n     */\n    private handleZone(payload: PayloadJson): void {\n        if (payload.zone) {\n            switch (payload.zone_event_type) {\n                case ZoneEventType.ZONE_ACTIVE:\n                    this.handleZoneActive(payload.zone);\n                    break;\n\n                case ZoneEventType.ZONE_ADD:\n                case ZoneEventType.ZONE_UPDATE:\n                    this.handleZoneUpdate(payload.zone);\n                    break;\n\n                case ZoneEventType.ZONE_DELETE:\n                    this.handleZoneDelete(payload.zone);\n                    break;\n\n                default:\n                    this.log.warn(\"unknown zone event type: \" + JSON.stringify(payload));\n                    break;\n            }\n        }\n    }\n\n    /**\n     * The handleZone function is called when a zone active event occurs.\n     * It locates and updates the matching partition zone detail and emits a complete 'zone' event.\n     *\n     * @param {ZoneJson} payload: The zone object of the event.\n     *\n     * @emits zone: Emits an event with a {ZoneJson} object\n     */\n    private handleZoneActive(payload: ZoneJson): void {\n        this.log.debug(\"zone active: \" + JSON.stringify(payload));\n        if (!this._partitions.some((partition) => {\n            return partition.zone_list.some((zone) => {\n                if (zone.zone_id === payload.zone_id) {\n                    this.emit(\"zone\", Object.assign(zone, payload), \"active\");\n                    return true;\n                }\n                return false;\n            })\n        })) {\n            this.log.warn(\"zone not found: \" + JSON.stringify(payload));\n        }\n    }\n\n    /**\n     * The handleZoneDelete function is called when a zone delete event occurs.\n     * Remove the matching partition zone and emits a complete 'zone' event.\n     *\n     * @param {ZoneJson} payload: The zone object of the event.\n     * *\n     * @emits zone: If the zone was found, emits a delete event with a {ZoneJson} object\n     */\n    private handleZoneDelete(payload: ZoneJson): void {\n        this.log.debug(\"zone delete: \" + JSON.stringify(payload));\n        this._partitions = this._partitions.map((partition) => {\n            const updatedPartition = { ...partition }; // Copy the partition object to avoid mutation\n            updatedPartition.zone_list = updatedPartition.zone_list.filter((z) => z.zone_id !== payload.zone_id);\n\n            // If zone was removed, emit 'delete' event\n            if (updatedPartition.zone_list.length < partition.zone_list.length) {\n                this.emit(\"zone\", payload, \"delete\");\n            } else {\n                this.log.debug(\"unable to delete zone: \" + JSON.stringify(payload));\n            }\n\n            return updatedPartition;\n        });\n    }\n\n    /**\n     * The handleZoneUpdate function is called when a zone update event occurs.\n     * It locates and updates any matching partition zone detail or adds a new one\n     * and emits a complete 'zone' event.\n     *\n     * @param {ZoneJson} payload: The zone object of the event\n     *\n     * @emits zone: Emits an event with a {ZoneJson} object\n     */\n    private handleZoneUpdate(payload: ZoneJson): void {\n        this.log.debug(\"zone update: \" + JSON.stringify(payload));\n        const partition = this._partitions.find(p => p.partition_id === payload.partition_id);\n        if (partition !== undefined) {\n            const idx = partition.zone_list.findIndex((z) => z.zone_id === payload.zone_id);\n            if (idx === -1) {\n                partition.zone_list.push(payload);\n            } else {\n                partition.zone_list[idx] = payload;\n            }\n        }\n        this.emit(\"zone\", payload, \"update\");\n    }\n\n    /**\n     * The onCountdown function is called when the countdown timer has been started.\n     * It emits an event to the client with a payload containing information about\n     * what type of arming is being performed, which partition it's for, and how many seconds are left in the delay.\n     *\n     * @param {number} seconds: Number of seconds left before the alarm is armed\n     * @param {ArmingJson} payload: The payload from the arming event to this function\n     */\n    private onCountdown(seconds: number, payload: ArmingJson): void {\n        this.emit(\"arming\", {\n            arming_type: payload.arming_type,\n            partition_id: payload.partition_id,\n            delay: seconds || payload.delay\n        });\n    }\n\n    /**\n     * The onCountdownStopped function is called when the countdown has stopped or completed.\n     * It emits the original arming payload event.\n     *\n     * @param {ArmingJson} payload: The payload from the arming event\n     *\n     * @emits arming: Emits an event with a {ArmingJson} object\n     */\n    private onCountdownStopped(payload: ArmingJson): void {\n        this.emit(\"arming\", payload);\n    }\n}\n"],
  "mappings": "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",
  "names": ["partition"]
}
