{
  "version": 3,
  "sources": ["../../src/lib/qolsys-panel-client.ts"],
  "sourcesContent": ["import { EventEmitter } from \"events\";\nimport { clearInterval } from \"timers\";\nimport { generateNonce } from \"./utils\";\nimport * as tls from \"tls\";\nimport { ActionType, AlarmType, ArmingStateType, InfoType } from \"../enums\";\nimport { PayloadJson } from \"../interfaces\";\n\nconst RECONNECT_INTERVAL = 10000; // Initial reconnect interval (10 seconds)\nconst MAX_RECONNECT_INTERVAL = 60000; // Maximum reconnect interval (60 seconds)\nconst PING_INTERVAL = 30000; // Ping interval (30 seconds)\n\n/**\n * Qolsys Panel Network Client.\n */\nexport class QolsysPanelClient extends EventEmitter {\n    private buffer = \"\";\n    private client?: tls.TLSSocket;\n    private readonly config: ioBroker.AdapterConfig;\n    private readonly log: ioBroker.Logger;\n    private pingTimer?: NodeJS.Timeout;\n    private reconnectInterval = RECONNECT_INTERVAL;\n    private reconnectTimer?: NodeJS.Timeout;\n\n    /**\n     * Qolsys Panel Client constructor.\n     *\n     * @param logger the ioBroker logger\n     * @param config the ioBroker configuration\n     */\n    constructor(logger: ioBroker.Logger, config: ioBroker.AdapterConfig) {\n        super();\n        this.config = config;\n        this.log = logger;\n    }\n\n    private _autoReconnect = true;\n\n    /**\n     * Get whether auto-reconnect is enabled (default is true).\n     */\n    public get autoReconnect(): boolean {\n        return this._autoReconnect;\n    }\n\n    /**\n     * Set whether auto-reconnect is enabled (default is true).\n     * @param value true to enable auto-reconnect\n     */\n    public set autoReconnect(value: boolean) {\n        this._autoReconnect = value;\n        if (!value) {\n            clearTimeout(this.reconnectTimer)\n            this.reconnectTimer = undefined;\n        }\n    }\n\n    private _lastAck = 0;\n\n    /**\n     * Return the timestamp of the last received ACK or 0 if no ACK has been received\n     */\n    get lastAck(): number {\n        return this._lastAck;\n    }\n\n    /**\n     * Returns whether the panel is connected.\n     *\n     * @return {boolean} true if the panel is connected, false otherwise\n     */\n    public get isConnected(): boolean {\n        return this.client?.readyState === \"open\";\n    }\n\n    /**\n     * Arm the panel in away mode.\n     * @param partitionId The partition ID\n     * @param delay The delay in seconds (0 for immediate)\n     */\n    public async armAway(partitionId: number, delay?: number): Promise<void> {\n        if (!this.config.enableArming) {\n            this.emit(\"error\", new Error(\"arming is not enabled in this adapter configuration\"));\n            return;\n        }\n\n        const json: PayloadJson = {\n            \"action\": ActionType.ARMING,\n            \"arming_type\": ArmingStateType.ARM_AWAY,\n            \"nonce\": generateNonce(),\n            \"partition_id\": partitionId,\n            \"source\": \"C4\",\n            \"token\": this.config.secureToken,\n            \"version\": 1\n        };\n        if (delay != null) {\n            json[\"delay\"] = delay;\n        }\n        await this.send(json);\n    }\n\n    /**\n     * Arm the panel in stay mode.\n     * @param partitionId The partition ID\n     */\n    public async armStay(partitionId: number): Promise<void> {\n        if (!this.config.enableArming) {\n            this.emit(\"error\", new Error(\"arming is not enabled in this adapter configuration\"));\n            return;\n        }\n\n        const json: PayloadJson = {\n            \"action\": ActionType.ARMING,\n            \"arming_type\": ArmingStateType.ARM_STAY,\n            \"nonce\": generateNonce(),\n            \"partition_id\": partitionId,\n            \"source\": \"C4\",\n            \"token\": this.config.secureToken,\n            \"version\": 1\n        };\n        await this.send(json);\n    }\n\n    /**\n     * Connects to the Qolsys panel.\n     *\n     * @emits ack - Acknowledgement from panel after command is received\n     * @emits data - Event payload from panel\n     * @emits close - When the panel connection is closed with a boolean hasError value\n     * @emits connect - When the panel has connected\n     * @emits error - Emits an event with a string describing the error\n     * @emits timeout - Emits an event when the inactivity timeout is reached\n     */\n    public connect(): void {\n        if (this.client) {\n            this.disconnect();\n        }\n\n        this.log.info(`connecting to the panel at ${this.config.host}:${this.config.port}`);\n        this.client = tls.connect(this.config.port, this.config.host, {\n            rejectUnauthorized: false\n        });\n\n        // Set encoding to UTF-8\n        this.client.setEncoding(\"utf8\");\n\n        // Disable Nagle algorithm\n        this.client.setNoDelay();\n\n        // Socket event handlers\n        this.client.on(\"close\", this.onClose.bind(this));\n        this.client.on(\"connect\", this.onConnect.bind(this));\n        this.client.on(\"data\", this.onData.bind(this));\n        this.client.on(\"error\", (err) => this.emit(\"error\", err));\n    }\n\n    /**\n     * Disarm the panel partition.\n     * @param partitionId The ID of the partition\n     * @param userPinCode The user pin code (defaults to the configuration userPinCode)\n     */\n    public async disarm(partitionId: number, userPinCode: string = this.config.userPinCode): Promise<void> {\n        if (!this.config.enableDisarming) {\n            this.emit(\"error\", new Error(\"disarming is not enabled in this adapter configuration\"));\n            return;\n        }\n\n        await this.send({\n            \"action\": ActionType.ARMING,\n            \"arming_type\": ArmingStateType.DISARM,\n            \"usercode\": userPinCode,\n            \"nonce\": generateNonce(),\n            \"partition_id\": partitionId,\n            \"source\": \"C4\",\n            \"token\": this.config.secureToken,\n            \"version\": 1\n        });\n    }\n\n    /**\n     * Disconnects from the Qolsys panel.\n     * This will generate a close event.\n     */\n    public disconnect(): void {\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = undefined;\n        }\n        this.buffer = \"\";\n        if (this.client) {\n            this.client.destroy();\n            this.client = undefined;\n        }\n    }\n\n    /**\n     * Requests panel summary.\n     */\n    public async requestSummary(): Promise<void> {\n        await this.send({\n            \"action\": ActionType.INFO,\n            \"info_type\": InfoType.SUMMARY,\n            \"nonce\": generateNonce(),\n            \"source\": \"C4\",\n            \"token\": this.config.secureToken,\n            \"version\": 1\n        });\n    }\n\n    /**\n     * Trigger the specified panel alarm.\n     * @param partitionId The partition ID\n     * @param alarmType The alarm type {@link AlarmType}\n     */\n    public async trigger(partitionId: number, alarmType: AlarmType): Promise<void> {\n        if (!this.config.enableAlarms) {\n            this.emit(\"error\", new Error(\"alarms are not enabled in this adapter configuration\"));\n            return;\n        }\n\n        await this.send({\n            \"action\": ActionType.ALARM,\n            \"alarm_type\": alarmType,\n            \"nonce\": generateNonce(),\n            \"partition_id\": partitionId,\n            \"source\": \"C4\",\n            \"token\": this.config.secureToken,\n            \"version\": 1\n        });\n    }\n\n    /**\n     * Invoked upon socket close.\n     * @param hadError whether the close was due to an error\n     */\n    private onClose(hadError: boolean): void {\n        this.log.info(`disconnected from the panel (hadError: ${hadError})`);\n        this.emit(\"close\", hadError);\n        clearInterval(this.pingTimer);\n        this.pingTimer = undefined;\n        this.scheduleReconnect();\n    }\n\n    /**\n     * Invoked upon successful connection to the panel.\n     */\n    private onConnect(): void {\n        this.log.info(\"connected to the panel\");\n\n        // Reset buffer\n        this.buffer = \"\";\n\n        // Connection successful, cancel reconnect and reset delay\n        clearTimeout(this.reconnectTimer);\n        this.reconnectTimer = undefined;\n        this.reconnectInterval = RECONNECT_INTERVAL;\n\n        // Set keep-alive timer\n        this.pingTimer = setInterval(this.ping.bind(this), PING_INTERVAL);\n\n        // Emit connected event\n        this.emit(\"connect\");\n    }\n\n    /**\n     * Invoked when socket receives data.\n     */\n    private onData(data: string): void {\n        this.buffer = this.parse(this.buffer + data);\n    }\n\n    /**\n     * Parses a buffer string, extracting and handling each line as a separate event.\n     * Recognizes \"ACK\" acknowledgement lines and parses other lines as JSON objects representing event payloads.\n     * Remaining buffer after parsing all complete lines is returned.\n     *\n     * @param {string} buffer - A string containing one or more newline-separated lines to be parsed.\n     *\n     * @emits ack - Acknowledgement from panel\n     * @emits data - Event payload from panel\n     * @emits error - Error from panel\n     *\n     * @return {string} A string containing the remaining buffer (if any).\n     */\n    private parse(buffer: string): string {\n        let newlineIndex;\n        while ((newlineIndex = buffer.indexOf(\"\\n\")) !== -1) {\n            // Extract next line and remove from buffer\n            const line = buffer.slice(0, newlineIndex);\n            buffer = buffer.slice(newlineIndex + 1);\n\n            // Command acknowledged\n            if (line === \"ACK\") {\n                this.log.debug(\"received ACK\");\n                this.emit(\"ack\");\n                this._lastAck = Date.now();\n                continue;\n            }\n\n            // Parse and handle the JSON object\n            this.log.debug(\"received: \" + line);\n            try {\n                const payload: PayloadJson = JSON.parse(line);\n                this.emit(\"data\", payload);\n            } catch (err: any) {\n                if (err instanceof SyntaxError) {\n                    this.emit(\"error\", new Error(`failed to parse JSON (${err.message}): ${line}`));\n                }\n            }\n        }\n        return buffer;\n    }\n\n    /**\n     * Sends a no-op command to the panel in expectation of an ACK response.\n     */\n    private ping(): void {\n        if (!this.isConnected || Date.now() - this._lastAck > PING_INTERVAL * 2) {\n            this.disconnect();\n            return;\n        }\n        this.log.debug(`sending ping`);\n        this.client?.write(\"\\n\");\n    }\n\n    /**\n     * Schedules a reconnect attempt to the panel.\n     * If a reconnect attempt is not already in progress, a reconnect attempt will be scheduled after a delay.\n     * The delay period doubles with each subsequent attempt up to a maximum of 60 seconds.\n     */\n    private scheduleReconnect(): void {\n        if (!this._autoReconnect) return;\n\n        // Don't schedule reconnect if we're already trying to reconnect\n        if (!this.reconnectTimer) {\n            this.reconnectTimer = setTimeout(() => {\n                // Double the reconnect delay for the next attempt, up to a maximum\n                this.reconnectInterval = Math.min(this.reconnectInterval * 2, MAX_RECONNECT_INTERVAL);\n                this.reconnectTimer = undefined;\n                this.connect();\n            }, this.reconnectInterval);\n\n            this.log.info(`reconnecting to the panel in ${this.reconnectInterval / 1000} seconds`);\n        }\n    }\n\n    /**\n     * Send the specified JSON object to the client.\n     *\n     * @param data The JSON object to write\n     * @returns A promise that resolves when the write operation is successful or rejects if there's an error\n     */\n    private async send(data: PayloadJson): Promise<void> {\n        const { client } = this;\n        if (!client) return;\n\n        return new Promise((resolve, reject) => {\n            const str = JSON.stringify(data);\n            this.log.debug(`sending: ${str}`);\n            client.write(str + \"\\n\", \"utf8\", (err: any) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n}\n\n/**\n * ACTION_KEY = \u2018action\u2019\n * ALARM_TYPE_KEY = \u2018alarm_type\u2019\n * ARMING_TYPE_KEY = \u2018arming_type\u2019\n * BYPASS_KEY = \u2018bypass\u2019\n * DELAY_KEY = \u2018delay\u2019\n * DESCRIPTION_KEY = \u2018description\u2019\n * ENTRY_DELAY_KEY = \u2018entry_delay\u2019\n * ERROR_TYPE_KEY = \u2018error_type\u2019\n * EVENT_KEY = \u2018event\u2019\n * EXIT_DELAY_KEY = \u2018exit_delay\u2019\n * ID_KEY = \u2018id\u2019\n * INFO_TYPE_KEY = \u2018info_type\u2019\n * NONCE_KEY = \u2018nonce\u2019\n * PARTITION_KEY = \u2018partition_id\u2019\n * PARTITION_LIST_KEY = \u2018partition_list\u2019\n * PARTITION_STATUS_KEY = \u2018status\u2019\n * SCOPE_KEY = \u2018scope\u2019\n * SECURE_ARM_KEY = \u2018secure_arm\u2019\n * SOURCE_KEY = \u2018source\u2019\n * TOKEN_KEY = \u2018token\u2019\n * USERCODE_KEY = \u2018usercode\u2019\n * VALUE_KEY = \u2018value\u2019\n * VERSION_KEY = \u2018version\u2019\n * ZONE_EVENT_TYPE_KEY = \u2018zone_event_type\u2019\n * ZONE_ID_KEY = \u2018zone_id\u2019\n * ZONE_KEY = \u2018zone\u2019\n * ZONE_LIST_KEY = \u2018zone_list\u2019\n * ZONE_NAME_KEY = \u2018name\u2019\n * ZONE_STATUS_KEY = \u2018status\u2019\n * ZONE_TYPE_KEY = \u2018zone_type\u2019\n *\n * ALARM_VAL = \u2018ALARM\u2019\n * ARMING_VAL = \u2018ARMING\u2019\n * ARM_AWAY_VAL = \u2018ARM_AWAY\u2019\n * ARM_STAY_VAL = \u2018ARM_STAY\u2019\n * AUX_VAL = \u2018AUXILIARY\u2019\n * DISARM_VAL = \u2018DISARM\u2019\n * FIRE_VAL = \u2018FIRE\u2019\n * INFO_VAL = \u2018INFO\u2019\n * POLICE_VAL = \u2018POLICE\u2019\n * SUMMARY_VAL = \u2018SUMMARY\u2019\n * ZONE_ACTIVATED_VAL = \u2018Activated\u2019\n * ZONE_ACTIVE_VAL = \u2018Active\u2019\n * ZONE_CLOSED_VAL = \u2018Closed\u2019\n * ZONE_EVENT_VAL = \u2018ZONE_EVENT\u2019\n * ZONE_IDLE_VAL = \u2018Idle\u2019\n * ZONE_NORMAL_VAL = \u2018Normal\u2019\n * ZONE_OPEN_VAL = \u2018Open\u2019\n */\n"],
  "mappings": "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",
  "names": []
}
