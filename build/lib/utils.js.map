{
  "version": 3,
  "sources": ["../../src/lib/utils.ts"],
  "sourcesContent": ["import crypto from \"crypto\";\nimport { SecurityZoneType } from \"../enums\";\nimport { ZoneJson } from \"../interfaces\";\n\n/**\n * Convert string to title case.\n * Examples:\n *\n * \"yourStringHere\" -> \"Your String Here\"\n * \"AnotherStringHere\" -> \"Another String Here\"\n * \"someones_string\" -> \"Someones String\"\n * \"Another-String-Here\" -> \"Another String Here\"\n * \"myAWESOMEString\" -> \"My AWESOME String\"\n *\n * @param str The string to convert\n * @return The converted string\n */\nexport function convertToTitleCase(str: string): string {\n    return str\n        .replace(/[_-]/g, \" \")\n        .trim()\n        .replace(/\\w\\S*/g, function (str) {\n            return str.charAt(0).toUpperCase() + str.slice(1)\n        })\n        .replace(/([a-z])([A-Z])/g, \"$1 $2\")\n        .replace(/([A-Z])([A-Z][a-z])/g, \"$1 $2\")\n}\n\n/**\n * Get the ioBroker role of a zone\n *\n * @param zone - The zone\n * @return The ioBroker role or undefined if not found\n */\nexport function getZoneRole(zone: ZoneJson): string | undefined {\n    switch (zone.zone_type) {\n        case SecurityZoneType.MOTION:\n        case SecurityZoneType.OCCUPANCY_SENSOR:\n        case SecurityZoneType.PANEL_MOTION:\n            return \"sensor.motion\";\n        case SecurityZoneType.BREAKAGE:\n        case SecurityZoneType.GLASSBREAK:\n        case SecurityZoneType.PANEL_GLASS_BREAK:\n        case SecurityZoneType.SHOCK:\n        case SecurityZoneType.SHOCK_OTHERS:\n        case SecurityZoneType.SHOCK_SENSOR_MULTI_FUNCTION:\n            return \"sensor.noise\";\n        case SecurityZoneType.SMOKE_HEAT:\n        case SecurityZoneType.SMOKE_MULTI_FUNCTION:\n            return \"sensor.alarm.fire\";\n        case SecurityZoneType.CONTACT:\n        case SecurityZoneType.CONTACT_MULTI_FUNCTION:\n        case SecurityZoneType.TAKEOVER_MODULE:\n        case SecurityZoneType.WIRED_SENSOR:\n            return /window/i.exec(zone.name) ? \"sensor.contact.window\" : \"sensor.contact.door\";\n        case SecurityZoneType.WATER:\n        case SecurityZoneType.WATER_IQ_FLOOD:\n        case SecurityZoneType.WATER_OTHER_FLOOD:\n            return \"sensor.alarm.flood\";\n        case SecurityZoneType.CARBON_MONOXIDE:\n        case SecurityZoneType.FREEZE:\n        case SecurityZoneType.RF_KEYPAD:\n        case SecurityZoneType.TEMPERATURE:\n        case SecurityZoneType.TEMPERATURE_MULTI_FUNCTION:\n            return \"sensor.alarm\";\n        default:\n            return undefined;\n    }\n}\n\n/**\n * Return path to a channel or state\n * @param device required device\n * @param channel required channel\n * @param stateName optional state name\n * @return path\n */\nexport function getPath(device: string, channel: string, stateName?: string): string {\n    return `${device}.${channel}` + (stateName ? `.${stateName}` : \"\");\n}\n\nlet counter = BigInt(0);\n\n/**\n * Generates a 96-bit (12-byte) nonce string. The most significant 4 bytes are random,\n * while the final 8 bytes are a sequential counter. The counter is designed to accommodate\n * up to 2^64 messages without repeating within a single program execution.\n *\n * @returns {string} The generated nonce as a hexadecimal string\n */\nexport function generateNonce(): string {\n    const random = crypto.randomBytes(4);\n    const sequential = counter++;\n\n    // Construct nonce from 4 bytes of random and 8 bytes sequential parts\n    const nonceBuffer = Buffer.alloc(12);\n    random.copy(nonceBuffer, 0, 0, 4); // Copy random part\n    nonceBuffer.writeBigInt64BE(sequential, 4); // Write sequential part\n\n    // Convert to hexadecimal string\n    return nonceBuffer.toString(\"hex\");\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAmB;AACnB,mBAAiC;AAgB1B,SAAS,mBAAmB,KAAqB;AACpD,SAAO,IACF,QAAQ,SAAS,GAAG,EACpB,KAAK,EACL,QAAQ,UAAU,SAAUA,MAAK;AAC9B,WAAOA,KAAI,OAAO,CAAC,EAAE,YAAY,IAAIA,KAAI,MAAM,CAAC;AAAA,EACpD,CAAC,EACA,QAAQ,mBAAmB,OAAO,EAClC,QAAQ,wBAAwB,OAAO;AAChD;AAQO,SAAS,YAAY,MAAoC;AAC5D,UAAQ,KAAK,WAAW;AAAA,IACpB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAClB,aAAO;AAAA,IACX,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAClB,aAAO;AAAA,IACX,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAClB,aAAO;AAAA,IACX,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAClB,aAAO,UAAU,KAAK,KAAK,IAAI,IAAI,0BAA0B;AAAA,IACjE,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAClB,aAAO;AAAA,IACX,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAAA,IACtB,KAAK,8BAAiB;AAClB,aAAO;AAAA,IACX;AACI,aAAO;AAAA,EACf;AACJ;AASO,SAAS,QAAQ,QAAgB,SAAiB,WAA4B;AACjF,SAAO,GAAG,UAAU,aAAa,YAAY,IAAI,cAAc;AACnE;AAEA,IAAI,UAAU,OAAO,CAAC;AASf,SAAS,gBAAwB;AACpC,QAAM,SAAS,cAAAC,QAAO,YAAY,CAAC;AACnC,QAAM,aAAa;AAGnB,QAAM,cAAc,OAAO,MAAM,EAAE;AACnC,SAAO,KAAK,aAAa,GAAG,GAAG,CAAC;AAChC,cAAY,gBAAgB,YAAY,CAAC;AAGzC,SAAO,YAAY,SAAS,KAAK;AACrC;",
  "names": ["str", "crypto"]
}
